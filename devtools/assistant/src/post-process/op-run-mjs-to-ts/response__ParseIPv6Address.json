{
  "result": "```typescript\nimport Operation from \"../Operation.tsx\";\nimport Utils from \"../Utils.mjs\";\nimport OperationError from \"../errors/OperationError.mjs\";\nimport { strToIpv6, ipv6ToStr, ipv4ToStr, IPV6_REGEX } from \"../lib/IP.mjs\";\nimport BigNumber from \"bignumber.js\";\n\n/**\n * Description: This class provides functionality to parse IPv6 addresses and display detailed information about them.\n */\nclass ParseIPv6Address extends Operation {\n  constructor() {\n    super();\n    this.name = \"Parse IPv6 address\";\n    this.module = \"Default\";\n    this.description = Dot(\"ipv6_desc\", \"Displays the longhand and shorthand versions of a valid IPv6 address. Recognises all reserved ranges and parses encapsulated or tunnelled addresses including Teredo and 6to4.\");\n    this.infoURL = \"https://wikipedia.org/wiki/IPv6_address\";\n    this.inputType = \"string\";\n    this.outputType = \"string\";\n    this.args = [];\n  }\n\n  run(input, args) {\n    let match, output = \"\";\n\n    if ((match = IPV6_REGEX.exec(input))) {\n      const ipv6 = strToIpv6(match[1]),\n        longhand = ipv6ToStr(ipv6),\n        shorthand = ipv6ToStr(ipv6, true);\n\n      output += \"Longhand:  \" + longhand + \"\\nShorthand: \" + shorthand + \"\\n\";\n\n      // Detect reserved addresses\n      if (shorthand === \"::\") {\n        // Unspecified address\n        output += \"\\n\" + Dot(\"unspec_addr\", \"Unspecified address corresponding to 0.0.0.0/32 in IPv4.\");\n        output += \"\\n\" + Dot(\"unspec_addr_range\", \"Unspecified address range: ::/128\");\n      } else if (shorthand === \"::1\") {\n        // Loopback address\n        output += \"\\n\" + Dot(\"loopback_addr\", \"Loopback address to the local host corresponding to 127.0.0.1/8 in IPv4.\");\n        output += \"\\n\" + Dot(\"loopback_addr_range\", \"Loopback addresses range: ::1/128\");\n      } else if (\n        ipv6[0] === 0 &&\n        ipv6[1] === 0 &&\n        ipv6[2] === 0 &&\n        ipv6[3] === 0 &&\n        ipv6[4] === 0 &&\n        ipv6[5] === 0xffff\n      ) {\n        // IPv4-mapped IPv6 address\n        output += \"\\n\" + Dot(\"ipv4_mapped\", \"IPv4-mapped IPv6 address detected. IPv6 clients will be handled natively by default, and IPv4 clients appear as IPv6 clients at their IPv4-mapped IPv6 address.\");\n        output += \"\\n\" + Dot(\"mapped_ipv4\", \"Mapped IPv4 address: \" + ipv4ToStr((ipv6[6] << 16) + ipv6[7]));\n        output += \"\\n\" + Dot(\"mapped_ipv4_range\", \"IPv4-mapped IPv6 addresses range: ::ffff:0:0/96\");\n      } else if (\n        ipv6[0] === 0 &&\n        ipv6[1] === 0 &&\n        ipv6[2] === 0 &&\n        ipv6[3] === 0 &&\n        ipv6[4] === 0xffff &&\n        ipv6[5] === 0\n      ) {\n        // IPv4-translated address\n        output += \"\\n\" + Dot(\"ipv4_translated\", \"IPv4-translated address detected. Used by Stateless IP/ICMP Translation (SIIT). See RFCs 6145 and 6052 for more details.\");\n        output += \"\\n\" + Dot(\"translated_ipv4\", \"Translated IPv4 address: \" + ipv4ToStr((ipv6[6] << 16) + ipv6[7]));\n        output += \"\\n\" + Dot(\"translated_ipv4_range\", \"IPv4-translated addresses range: ::ffff:0:0:0/96\");\n      } else if (ipv6[0] === 0x100) {\n        // Discard prefix per RFC 6666\n        output += \"\\n\" + Dot(\"discard_prefix\", \"Discard prefix detected. This is used when forwarding traffic to a sinkhole router to mitigate the effects of a denial-of-service attack. See RFC 6666 for more details.\");\n        output += \"\\n\" + Dot(\"discard_range\", \"Discard range: 100::/64\");\n      } else if (\n        ipv6[0] === 0x64 &&\n        ipv6[1] === 0xff9b &&\n        ipv6[2] === 0 &&\n        ipv6[3] === 0 &&\n        ipv6[4] === 0 &&\n        ipv6[5",
  "response": {
    "choices": [
      {
        "finish_reason": "length",
        "index": 0,
        "message": {
          "content": "```typescript\nimport Operation from \"../Operation.tsx\";\nimport Utils from \"../Utils.mjs\";\nimport OperationError from \"../errors/OperationError.mjs\";\nimport { strToIpv6, ipv6ToStr, ipv4ToStr, IPV6_REGEX } from \"../lib/IP.mjs\";\nimport BigNumber from \"bignumber.js\";\n\n/**\n * Description: This class provides functionality to parse IPv6 addresses and display detailed information about them.\n */\nclass ParseIPv6Address extends Operation {\n  constructor() {\n    super();\n    this.name = \"Parse IPv6 address\";\n    this.module = \"Default\";\n    this.description = Dot(\"ipv6_desc\", \"Displays the longhand and shorthand versions of a valid IPv6 address. Recognises all reserved ranges and parses encapsulated or tunnelled addresses including Teredo and 6to4.\");\n    this.infoURL = \"https://wikipedia.org/wiki/IPv6_address\";\n    this.inputType = \"string\";\n    this.outputType = \"string\";\n    this.args = [];\n  }\n\n  run(input, args) {\n    let match, output = \"\";\n\n    if ((match = IPV6_REGEX.exec(input))) {\n      const ipv6 = strToIpv6(match[1]),\n        longhand = ipv6ToStr(ipv6),\n        shorthand = ipv6ToStr(ipv6, true);\n\n      output += \"Longhand:  \" + longhand + \"\\nShorthand: \" + shorthand + \"\\n\";\n\n      // Detect reserved addresses\n      if (shorthand === \"::\") {\n        // Unspecified address\n        output += \"\\n\" + Dot(\"unspec_addr\", \"Unspecified address corresponding to 0.0.0.0/32 in IPv4.\");\n        output += \"\\n\" + Dot(\"unspec_addr_range\", \"Unspecified address range: ::/128\");\n      } else if (shorthand === \"::1\") {\n        // Loopback address\n        output += \"\\n\" + Dot(\"loopback_addr\", \"Loopback address to the local host corresponding to 127.0.0.1/8 in IPv4.\");\n        output += \"\\n\" + Dot(\"loopback_addr_range\", \"Loopback addresses range: ::1/128\");\n      } else if (\n        ipv6[0] === 0 &&\n        ipv6[1] === 0 &&\n        ipv6[2] === 0 &&\n        ipv6[3] === 0 &&\n        ipv6[4] === 0 &&\n        ipv6[5] === 0xffff\n      ) {\n        // IPv4-mapped IPv6 address\n        output += \"\\n\" + Dot(\"ipv4_mapped\", \"IPv4-mapped IPv6 address detected. IPv6 clients will be handled natively by default, and IPv4 clients appear as IPv6 clients at their IPv4-mapped IPv6 address.\");\n        output += \"\\n\" + Dot(\"mapped_ipv4\", \"Mapped IPv4 address: \" + ipv4ToStr((ipv6[6] << 16) + ipv6[7]));\n        output += \"\\n\" + Dot(\"mapped_ipv4_range\", \"IPv4-mapped IPv6 addresses range: ::ffff:0:0/96\");\n      } else if (\n        ipv6[0] === 0 &&\n        ipv6[1] === 0 &&\n        ipv6[2] === 0 &&\n        ipv6[3] === 0 &&\n        ipv6[4] === 0xffff &&\n        ipv6[5] === 0\n      ) {\n        // IPv4-translated address\n        output += \"\\n\" + Dot(\"ipv4_translated\", \"IPv4-translated address detected. Used by Stateless IP/ICMP Translation (SIIT). See RFCs 6145 and 6052 for more details.\");\n        output += \"\\n\" + Dot(\"translated_ipv4\", \"Translated IPv4 address: \" + ipv4ToStr((ipv6[6] << 16) + ipv6[7]));\n        output += \"\\n\" + Dot(\"translated_ipv4_range\", \"IPv4-translated addresses range: ::ffff:0:0:0/96\");\n      } else if (ipv6[0] === 0x100) {\n        // Discard prefix per RFC 6666\n        output += \"\\n\" + Dot(\"discard_prefix\", \"Discard prefix detected. This is used when forwarding traffic to a sinkhole router to mitigate the effects of a denial-of-service attack. See RFC 6666 for more details.\");\n        output += \"\\n\" + Dot(\"discard_range\", \"Discard range: 100::/64\");\n      } else if (\n        ipv6[0] === 0x64 &&\n        ipv6[1] === 0xff9b &&\n        ipv6[2] === 0 &&\n        ipv6[3] === 0 &&\n        ipv6[4] === 0 &&\n        ipv6[5",
          "role": "assistant"
        }
      }
    ],
    "created": 1713892219,
    "id": "8596356117976512945",
    "model": "glm-4",
    "request_id": "8596356117976512945",
    "usage": {
      "completion_tokens": 1024,
      "prompt_tokens": 4367,
      "total_tokens": 5391
    }
  }
}