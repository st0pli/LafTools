{
    "R_S7_CLAo": "範例：要使用 Base32 編碼“TEST12345”，您可以使用 Node.js 中的 base32-encode 等函式庫，或其他語言中的內建函數（例如 Python 的 base64.b32encode）。",
    "a4s6x": "Base32 是如何運作的？",
    "a8b7z": "因此，只有當編碼的最後一組位元不能被 40 位元整除時才需要填入（因為 8 個 Base32 字元代表 40 位元）。填充將由編碼字串末尾的零到六個“=”字元組成。",
    "b8g2k": "Base32的使用場景",
    "c0v2p": "Base32的常見操作",
    "d1x7v": "另一個例子是在 Git 中，雜湊物件有時以 Base32 格式儲存，以避免行結尾和檔案名稱限製問題。此外，HashiCorp Vault 使用 Base32 進行金鑰派生。",
    "d9w7m": "此外，由於它只使用大寫字母，因此它無法像 Base64 有時在解碼期間使用大小寫折疊那樣利用所有可能的區分大小寫組合作為附加安全措施。",
    "e5c7r": "Base32 是一種二進位到文字的編碼方案，使用 32 個字元的子集表示 ASCII 字串中的資料。它被設計為人類可讀且 URL 安全。",
    "f0q4w": "一個流行的使用場景是為雙重認證 (2FA) 產生密鑰，其中 Google Authenticator 和 Yubikey 等服務使用 Base32 編碼的密鑰。",
    "f5a0s": "此外，Base32 會產生更長的輸出，但由於缺少可能與檔案系統規則衝突的特殊字符，因此更適合特定應用程式（例如檔案名稱）。",
    "g8r3e": "Base32的主要缺點是空間效率相對較差；它比 Base64 將輸入資料擴展了大約 25%。這意味著相同數量的編碼資料會佔用更多的儲存或頻寬。",
    "h4e1b": "對於區分大小寫的字母數字字串比十六進製或base64 更容易處理的情況也很有用，因為十六進製或base64 可能包含非字母數字字符，這些字符可能會在某些上下文（例如URL或檔案名稱）中導致問題。",
    "h9j3m": "Base32 中的填充",
    "i9o7k": "Base32 相對於 Base64 的優勢",
    "j1b5k": "涉及 Base32 的最常見操作包括將二進位資料編碼為 Base32 字串以及將 Base32 字串解碼回其原始二進位格式。",
    "k7g0n": "在 Base32 中，輸入資料的每 5 位都對應到「ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=」集合中的 32 個字元之一。",
    "l1p9z": "什麼是 Base32？",
    "m6d8b": "每個 5 位元值都由單一字元表示，因此可以為喜歡使用八位元組（8 位元單元）的系統進行高效編碼和解碼。",
    "n3e7r": "Base32 的歷史",
    "p9s5t": "Base32 由因其對 JavaScript 的貢獻而聞名的 Douglas Crockford 於 2001 年開發。它是作為 Base64 等現有編碼的更可靠的替代方案而創建的，特別是對於需要基於文本的二進製數據表示的情況。",
    "q2w5m": "使用Base32的目的？",
    "s5t0n": "Base32 中的填充涉及添加“=”字符，以確保編碼資料的最終區塊仍包含 8 位的倍數。然而，與 Base64 不同的是，Base32 填充很少，因為每個 Base32 字元已經編碼了 5 位元。",
    "t8z1v": "當末尾沒有足夠的位元來填充完整的 5 位元組時，將添加填充字元“=”。例如，一個位元組需要兩個 Base32 字符，一個 3 位元組序列需要四個 Base32 字符。",
    "u3j9p": "當您需要可以鍵入或列印而不會遺失資訊的二進位資料的緊湊文字表示形式時，通常會使用 Base32，例如檔案完整性檢查、地理快取和安全密碼產生。",
    "y6t1n": "Base32的缺點",
    "z2x8c": "Base32 的視覺歧義較少，因為它只使用大寫字母和數字，與包含「+」、「/」和小寫字母的 Base64 相比，更容易手動或透過電話閱讀和轉錄。",
    "z6m1c": "後來引入了 z-base-32 等變體來提高可用性，用其他字符替換了一些不太容易記住的字符，但 Crockford 的原始規範至今仍被廣泛使用。"
}