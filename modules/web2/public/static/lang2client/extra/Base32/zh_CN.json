{
    "R_S7_CLAo": "示例：要使用 Base32 编码“TEST12345”，您可以使用 Node.js 中的 base32-encode 等库，或其他语言中的内置函数（例如 Python 的 base64.b32encode）。",
    "a4s6x": "Base32 是如何工作的？",
    "a8b7z": "因此，仅当编码的最后一组位不能被 40 位整除时才需要填充（因为 8 个 Base32 字符代表 40 位）。填充将由编码字符串末尾的零到六个“=”字符组成。",
    "b8g2k": "Base32的使用场景",
    "c0v2p": "Base32的常见操作",
    "d1x7v": "另一个例子是在 Git 中，散列对象有时以 Base32 格式存储，以避免行结尾和文件名限制问题。此外，HashiCorp Vault 使用 Base32 进行密钥派生。",
    "d9w7m": "此外，由于它仅使用大写字母，因此它无法像 Base64 有时在解码期间使用大小写折叠那样利用所有可能的区分大小写组合作为附加安全措施。",
    "e5c7r": "Base32 是一种二进制到文本的编码方案，使用 32 个字符的子集表示 ASCII 字符串中的数据。它被设计为人类可读且 URL 安全。",
    "f0q4w": "一种流行的使用场景是为双因素身份验证 (2FA) 生成密钥，其中 Google Authenticator 和 Yubikey 等服务使用 Base32 编码的密钥。",
    "f5a0s": "此外，Base32 会产生更长的输出，但由于缺少可能与文件系统规则冲突的特殊字符，因此更适合特定应用程序（例如文件名）。",
    "g8r3e": "Base32的主要缺点是空间效率相对较差；它比 Base64 将输入数据扩展了大约 25%。这意味着相同数量的编码数据会占用更多的存储或带宽。",
    "h4e1b": "对于区分大小写的字母数字字符串比十六进制或 base64 更容易处理的情况也很有用，因为十六进制或 base64 可能包含非字母数字字符，这些字符可能会在某些上下文（例如 URL 或文件名）中导致问题。",
    "h9j3m": "Base32 中的填充",
    "i9o7k": "Base32 相对于 Base64 的优势",
    "j1b5k": "涉及 Base32 的最常见操作包括将二进制数据编码为 Base32 字符串以及将 Base32 字符串解码回其原始二进制格式。",
    "k7g0n": "在 Base32 中，输入数据的每 5 位都映射到“ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=”集合中的 32 个字符之一。",
    "l1p9z": "什么是 Base32？",
    "m6d8b": "每个 5 位值都由单个字符表示，从而可以为喜欢使用八位字节（8 位单元）的系统进行高效编码和解码。",
    "n3e7r": "Base32 的历史",
    "p9s5t": "Base32 由因其对 JavaScript 的贡献而闻名的 Douglas Crockford 于 2001 年开发。它是作为 Base64 等现有编码的更可靠的替代方案而创建的，特别是对于需要基于文本的二进制数据表示的情况。",
    "q2w5m": "使用Base32的目的？",
    "s5t0n": "Base32 中的填充涉及添加“=”字符，以确保编码数据的最终块仍包含 8 位的倍数。然而，与 Base64 不同的是，Base32 填充很少，因为每个 Base32 字符已经编码了 5 位。",
    "t8z1v": "当末尾没有足够的位来填充完整的 5 位组时，将添加填充字符“=”。例如，一个字节需要两个 Base32 字符，一个 3 字节序列需要四个 Base32 字符。",
    "u3j9p": "当您需要可以键入或打印而不会丢失信息的二进制数据的紧凑文本表示形式时，通常会使用 Base32，例如文件完整性检查、地理缓存和安全密码生成。",
    "y6t1n": "Base32的缺点",
    "z2x8c": "Base32 的视觉歧义较少，因为它仅使用大写字母和数字，与包含“+”、“/”和小写字母的 Base64 相比，更容易手动或通过电话阅读和转录。",
    "z6m1c": "后来引入了 z-base-32 等变体来提高可用性，用其他字符替换了一些不太容易记住的字符，但 Crockford 的原始规范至今仍被广泛使用。"
}